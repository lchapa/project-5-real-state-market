const fs = require('fs');

// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
var verifier = artifacts.require('Verifier');
var solutionVerifier = artifacts.require('SolnSquareVerifier');



contract('TestSolutionVerifier', accounts => {
    const account_one = accounts[0];
    const account_two = accounts[1];

	// Test if a new solution can be added for contract - SolnSquareVerifier
	describe('Test Solution Verifier', function () {
    	let proofs = [];
    	before(async() => {
    		const proofsFor = JSON.parse(fs.readFileSync(__dirname + '/../zokrates/proofsFor.json'));
    		for(let i = 0; i < proofsFor.total; i++) {
    			proofs.push(JSON.parse(fs.readFileSync(__dirname + '/../zokrates/proof' + proofsFor.inputs[i].a + proofsFor.inputs[i].b +'.json')));
    		}
    	});            
    		
        beforeEach(async function () { 

    		let verifierInstance = await verifier.new({from: account_one});
            assert.isNotNull(verifierInstance, "Could not create verifier contract");
            
            this.contract = await solutionVerifier.new("Real State NFT", "REA", verifierInstance.address, {from: account_one});
            assert.isNotNull(this.contract, "Could not create Solution Verifier contract");            
    	});
		
        // Test if a new solution can be added for contract - SolnSquareVerifier
        it('Test if a new solution can be added for contract - SolnSquareVerifier', async function () { 
        	
        	let p = proofs[0];
        	let result = await this.contract.addSolution(p.proof, p.inputs, {from: account_two});
        	result.logs.forEach(l => {
            	if(l.event === 'SolutionAdded') {            		
                	console.log("Solution Added:" + l.args.solutionIndex);
            		assert.isTrue(web3.utils.toBN(l.args.solutionIndex).eq(web3.utils.toBN(1)), "First solution added");
            		assert.isTrue(web3.utils.toBN(l.args.solutionAddress).eq(web3.utils.toBN(account_two)), "To account is not the same");
            	}
            });
        	
        	//Add the same solution again
        	try {
            	let result =  await this.contract.addSolution(p.proof, p.inputs, {from: account_two});
            	assert.isNotOk("Must fail trying to add the same solution");
        	} catch(e) {
        		console.log(e.message);
        		assert.include(e.message, 'Solution already added', 'Unexpected error: [' + e.message + ']');        		
        	}
        });
        
        // Test if an ERC721 token can be minted for contract - SolnSquareVerifier
        it('Test if an ERC721 token can be minted for contract - SolnSquareVerifier', async function () {
        	let p = proofs[0];

        	let resultAdded = await this.contract.addSolution(p.proof, p.inputs, {from: account_one});
        	resultAdded.logs.forEach(l => {
            	if(l.event === 'SolutionAdded') {            		
            		assert.isTrue(l.args.solutionIndex == 1, "First solution added");
            		assert.isTrue(web3.utils.toBN(l.args.solutionAddress).eq(web3.utils.toBN(account_one)), "To account is not the same");
                	console.log("Solution Address:" + l.args.solutionIndex);
            	}
            });
        	
        	let resultMinted = await this.contract.mintNFT(p.inputs, {from: account_one});
        	resultMinted.logs.forEach(l => {
            	if(l.event === 'Transfer') {
                	console.log("Minted TokenId:" + l.args.tokenId);
            		assert.isTrue(web3.utils.toBN(l.args.from).eq(web3.utils.toBN(0x0)), "From account is not the same");
            		assert.isTrue(web3.utils.toBN(l.args.to).eq(web3.utils.toBN(account_one)), "To account is not the same");
            		assert.isTrue(web3.utils.toBN(l.args.tokenId).eq(web3.utils.toBN(1)), "First token minted");
            	}
            });
        	
        	// try to mint again the same solution
        	try {
            	let result = await this.contract.mintNFT(p.inputs, {from: account_one});
            	assert.isNotOk('It must launch and exception when try to mint a token again');
        	} catch(e) {
        		console.log(e.message);
        		assert.include(e.message, 'Solution was already minted', 'Unexpected error: [' + e.message + ']');        		
        	}
        	
        	// try to mint a token without solution yet.
        	try {
        		let p2 = proofs[1];        		
            	let result =  await this.contract.mintNFT(p2.inputs, {from: account_one});
            	assert.isNotOk('It must launch and exception when try to mint a token withput solution');
        		
        	} catch(e) {
        		console.log(e.message);
        		assert.include(e.message, 'Solution does not exist yet', 'Unexpected error: [' + e.message + ']');        		
        	}
        });
	});
	
	
	
	
});





